dmvnorm(c(iseq[i],jseq[j]),mean=c(x[p],y[p]),sigma=covmat)
})
z[i,j] = sum(d)
}
}
z.scaled = apply(z, c(1,2), function(v){
1/(max(z)-min(z))*(v-min(z))
})
plot(x,y, pch=19, xlim=c(0,11), ylim=c(0,11), type='n')
for(j in 1:length(jseq)){
for(i in 1:length(iseq)){
points(iseq[i], jseq[j], pch=15,
col=rgb(z.scaled[i,j],z.scaled[i,j],z.scaled[i,j])
)
}
}
points(x,y,pch=19,col='red',cex=1.5)
x.3d = rep(iseq, each=91)
x.3d = rep(iseq, each=91)
y.3d = rep(jseq, times=91)
colorlut <- terrain.colors(length(unique(z.scaled))) # height color lookup table
col <- colorlut[ order(z.scaled) ] # assign colors to heights for each point
rgl.surface(iseq,jseq,z.scaled*5,color=col,back='filled')
rgl.surface(iseq,jseq,z.scaled*5,color=col,back='filled')
plot(x,y, pch=19, xlim=c(0,11), ylim=c(0,11))
xspline(x,y,shape=-0.95,border='red',lwd=2)
z=xspline(x,y,shape=-0.95,border='red',lwd=2, draw=FALSE)
sapply(1:(length(z$x)-1), function(i) {
lines(z$x[c(i,i+1)],z$y[c(i,i+1)],lwd=seq(20,1,length.out=274)[i])
})
plot(x,y, pch=19, xlim=c(0,11), ylim=c(0,11))
correl = runif(pts, -0.6, 0.6)
for(i in 1:length(iseq)){
for(j in 1:length(jseq)){
d = sapply( 1:length(x), function(p) {
covmat = diag(2)
covmat[1,2] = correl[p]
covmat[2,1] = correl[p]
dmvnorm(c(iseq[i],jseq[j]),mean=c(x[p],y[p]),sigma=covmat)
})
z[i,j] = sum(d)
}
}
pts = 10
for(i in 1:length(iseq)){
for(j in 1:length(jseq)){
d = sapply( 1:length(x), function(p) {
covmat = diag(2)
covmat[1,2] = correl[p]
covmat[2,1] = correl[p]
dmvnorm(c(iseq[i],jseq[j]),mean=c(x[p],y[p]),sigma=covmat)
})
z[i,j] = sum(d)
}
}
iseq = seq(1,10,by=rez)
jseq = seq(1,10,by=rez)
z = matrix(rep(0,length(iseq)*length(iseq)),nrow=length(iseq))
plot(x,y, pch=19, xlim=c(0,11), ylim=c(0,11))
correl = runif(pts, -0.6, 0.6)
for(i in 1:length(iseq)){
for(j in 1:length(jseq)){
d = sapply( 1:length(x), function(p) {
covmat = diag(2)
covmat[1,2] = correl[p]
covmat[2,1] = correl[p]
dmvnorm(c(iseq[i],jseq[j]),mean=c(x[p],y[p]),sigma=covmat)
})
z[i,j] = sum(d)
}
}
z.scaled = apply(z, c(1,2), function(v){
1/(max(z)-min(z))*(v-min(z))
})
plot(x,y, pch=19, xlim=c(0,11), ylim=c(0,11), type='n')
for(j in 1:length(jseq)){
for(i in 1:length(iseq)){
points(iseq[i], jseq[j], pch=15,
col=rgb(z.scaled[i,j],z.scaled[i,j],z.scaled[i,j])
)
}
}
points(x,y,pch=19,col='red',cex=1.5)
x.3d = rep(iseq, each=91)
y.3d = rep(jseq, times=91)
colorlut <- terrain.colors(length(unique(z.scaled))) # height color lookup table
col <- colorlut[ order(z.scaled) ] # assign colors to heights for each point
rgl.surface(iseq,jseq,z.scaled*5,color=col,back='filled')
plot(x,y, pch=19, xlim=c(0,11), ylim=c(0,11), type='n')
xspline(x,y,shape=-0.95,border='red',lwd=2)
plot(x,y, pch=19, xlim=c(0,11), ylim=c(0,11), type='n')
z=xspline(x,y,shape=-0.95,border='red',lwd=2, draw=FALSE)
sapply(1:(length(z$x)-1), function(i) {
lines(z$x[c(i,i+1)],z$y[c(i,i+1)],lwd=seq(20,1,length.out=274)[i])
})
source('~/WorkingData/BI_git/sandbox/kdelisle/SomaR_Releases/SomaR-1.8.0/revert.pkg.version.R')
revert.pkg.version('~/WorkingData/BI_git/sandbox/kdelisle/SomaR_Releases/SomaR-1.8.0/', 'SomaR')
ls
d = read.adat('WorkingData/Datasets/SomaLogic/Covance/CL-15-128.Plasma.3n.HybMedNormCal.adat')
tn= get.target.names(d)
grep('Serine protease 27', tn)
grep('Serine',tn)
tn
d
tn = get.target.names(get.apt.data(d))
library(magrittr)
tn = get.target.names(get.apt.data(d))
grep('Serine',tn)
grep('Serine protease 27', tn)
tn[[2443]]
names(tn)[2443]
hist(d$PRSS27.3624.3.4)
loess(d$PRSS27.3624.3.4)
density(d$PRSS27.3624.3.4,add=TRUE)
plot(density(d$PRSS27.3624.3.4),add=TRUE)
h =hist(d$PRSS27.3624.3.4)
h$breaks
brks = seq(100,15000,by=100)
brks
h =hist(d$PRSS27.3624.3.4, breaks=brks)
grep('Dickkopf', tn)
grep('Dickkopf-like protein 1', tn)
names(tn)[2455]
h =hist(d$DKKL1.3644.5.4, breaks=brks)
plot(density(d$DKKL1.3644.5.4),add=TRUE)
plot(density(d$DKKL1.3644.5.4),add=TRUE, breaks=brks)
warnings()
warnings()
warnings()
warnings()
warnings()
warnings()
source('~/WorkingData/BI_git/sandbox/kdelisle/SomaR_Releases/SomaR-1.8.0/revert.pkg.version.R')
revert.pkg.version('~/WorkingData/BI_git/sandbox/kdelisle/SomaR_Releases/SomaR-1.8.0/', 'SomaR')
source('~/WorkingData/BI_git/sandbox/kdelisle/SomaR_Releases/SomaR-1.8.0/load.pkg.objects.R')
source('~/WorkingData/BI_git/sandbox/kdelisle/SomaR_Releases/SomaR-1.8.0/revert.pkg.version.R')
revert.pkg.version('~/WorkingData/BI_git/sandbox/kdelisle/SomaR_Releases/SomaR-1.8.0/', 'SomaR')
library(e1071)
?naive
source('~/WorkingData/BI_git/sandbox/kdelisle/SomaR_Releases/SomaR-1.8.0/load.pkg.objects.R')
d = read('~/WorkingData/BI_git/r/SomaData/data/CovanceReferenceData.rda')
d = load('~/WorkingData/BI_git/r/SomaData/data/CovanceReferenceData.rda')
d
class(d)
d = load('~/WorkingData/BI_git/r/SomaData/data/CovanceReferenceData.rda')
load("~/WorkingData/BI_git/r/SomaData/data/CovanceReferenceData.rda")
d=CovanceReferenceData$plasma
d
res = naiveBayes(d$GENDER~d$CST3.2609.59.2)
res = naiveBayes(GENDER~CST3.2609.59.2, data=d)
res
structure(res)
res = naiveBayes(GENDER~CST3.2609.59.2+LDHB.3890.8.2, data=d)
res
predict(res,d[1,])
predict(res,d[2,])
predict(res,d[1:10,])
warnings()
warnings()
warnings()
warnings()
warnings()
warnings()
warnings()
warnings()
warnings()
res = naiveBayes(GENDER~CST3.2609.59.2+LDHB.3890.8.2, data=d)
res
predict(res, newdata=CovanceReferenceData)
predict(res, newdata=d)
res
warnings()
p =predict(res, newdata=d)
p
structure(p)
;
p
class(p)
res = naiveBayes(GENDER~CST3.2609.59.2+LDHB.3890.8.2, data=d)
p = predict(res, newdata = d[, c('CST3.2609.59.2','LDHB.3890.8.2')])
p
data(HouseVotes84)
model <- naiveBayes(Class ~ ., data = HouseVotes84)
predict(model, HouseVotes84[1:10,-1])
predict(model, HouseVotes84[1:10,-1], type = "raw")
library(data)
library(datasets)
data(HouseVotes84)
model <- naiveBayes(Class ~ ., data = HouseVotes84)
predict(model, HouseVotes84[1:10,-1])
predict(model, HouseVotes84[1:10,-1], type = "raw")
datasets(HouseVotes84)
data(house.votes.84)
library(datasets)
data(HouseVotes84)
data()
data(Titanic)
m <- naiveBayes(Survived ~ ., data = Titanic)
m
predict(m, as.data.frame(Titanic)[,1:3])
res
head(Titanic)
Titanic
p = predict(res, newdata = d[, c('CST3.2609.59.2','LDHB.3890.8.2')], type='raw')
p
plot(p$F)
class(p)
table(p)
plot(p[,1],d$GENDER)
plot(p[,1])
p[,1]
head(p)
res = naiveBayes(GENDER~LDHB.3890.8.2, data=d)
res
p = predict(res, newdata = d[, c('CST3.2609.59.2','LDHB.3890.8.2')], threshold=0.5)
p
p = predict(res, newdata = d[, c('CST3.2609.59.2','LDHB.3890.8.2')], type='raw')
p
head(p)
p=data.frame(p)
p
head(p)
p$GENDER = d$GENDER
head(p)
d$GENDER
boxplot(p$F~d$GENDER)
boxplot(d$LDHB.3890.8.2~d$GENDER)
boxplot(d$CGA.FSHB.3032.11.2~d$GENDER)
boxplot(d$CGA.LHB.2953.31.2~d$GENDER)
res = naiveBayes(GENDER~CGA.LHB.2953.31.2, data=d)
res
p = predict(res, newdata = d[, c('CST3.2609.59.2','LDHB.3890.8.2')], type='raw')
p
head(p)
p = predict(res, newdata = d[, c('CST3.2609.59.2','LDHB.3890.8.2')])
p
p = predict(res, newdata = d[, c('CGA.LHB.2953.31.2')])
p
p = predict(res, newdata = d[, c('CGA.LHB.2953.31.2')], type='raw')
p
p = predict(res, newdata = d, type='raw')
p
p = predict(res, newdata =d)
p
p = predict(res, newdata = d, type='raw')
p
pdf = data.frame(p)
pdf$GENDER = d$GENDER
boxplot(pdf$F~d$GENDER)
boxplot(pdf$M~d$GENDER)
d$CGA.LHB.2953.31.2
library(kknn)
install.packages(c("backports", "BH", "checkmate", "crayon", "curl", "data.table", "dplyr", "evaluate", "Formula", "glmnet", "gridExtra", "heatmaply", "htmlwidgets", "httr", "knitr", "lambda.r", "lme4", "multcomp", "npsurv", "openssl", "plotly", "processx", "purrr", "Rcpp", "reticulate", "rJava", "rlang", "sandwich", "scales", "shiny", "tensorflow", "tibble", "tidyr"))
library(kknn)
library(igraph)
install.packages("npsurv")
df = data.frame(resp = sample( c(rep(1,50), rep(0,50)), replace=FALSE))
df
d = matrix(rnorm(5000*100), nrow=100)
df = cbind(df, d)
df
df$`1`
names(df) = c('resp', sprintf('Var_%d'), 1:5000)
dim(df)
names(df) = c('resp', sprintf('Var_%d', 1:5000))
names(df)
tail(names(df))
library(glmnet)
df = data.frame(resp = sample( c(rep(1,50), rep(0,50)), replace=FALSE))
d = matrix(rnorm(5000*100), nrow=100)
df = cbind(df, d)
names(df) = c('resp', sprintf('Var_%d', 1:5000))
i=1
eval(names(df)[i])
i=2
lr = glmnet( resp ~ eval(names(df)[i]))
lr = glmnet( resp ~ eval(names(df)[i]), family='logistic')
lr = glmnet( resp ~ eval(names(df)[i]), family='binomial')
lr = glmnet( y=resp x=eval(names(df)[i]), family='binomial')
lr = glmnet( y=resp, x=eval(names(df)[i]), family='binomial')
lr = glmnet( y=df$resp, df[,i], family='binomial')
?glmnet
lr = glm(resp~eval(names(df)[i]), data=df, family=binomial(link='logit'))
names(df)[i]
lr = glm(as.formula('resp~%s', names(df)[i]), data=df, family=binomial(link='logit'))
lr = glm(as.formula('resp~%s', names(df)[i]), data=df, family=binomial(link='logit'))
as.formula('resp~%s', names(df)[i])
lr = glm(as.formula(sprintf('resp ~ %s', names(df)[i])), data=df, family=binomial(link='logit'))
lr
summary(lr)
s = summary(lr)
s
s$coefficients
s$coefficients[2,4]
s = summary(lr)$coefficients[2,4]
s
uni.lr = sapply(c(2:5001), function(i) {
lr = glm(as.formula(sprintf('resp ~ %s', names(df)[i])), data=df, family=binomial(link='logit'))
s = summary(lr)$coefficients[2,4]
}
)
uni.lr
length(uni.lr)
uni.lr.fdr = p.adjust(uni.lr, method='fdr')
hist(uni.lr.fdr)
uni.lr.fdr
range(uni.lr.fdr)
df = data.frame(resp = sample( c(rep(1,50), rep(0,50)), replace=FALSE))
d = matrix(rnorm(5000*100), nrow=100)
df = cbind(df, d)
names(df) = c('resp', sprintf('Var_%d', 1:5000))
uni.lr = sapply(c(2:5001), function(i) {
lr = glm(as.formula(sprintf('resp ~ %s', names(df)[i])), data=df, family=binomial(link='logit'))
s = summary(lr)$coefficients[2,4]
})
uni.lr.fdr = p.adjust(uni.lr, method='fdr')
range(uni.lr.fdr)
range(uni.lr)
range(uni.lr*5000)
source('~/WorkingData/BI_git/sandbox/kdelisle/SomaR_Releases/SomaR-2.0.0/revert.pkg.version.R')
source('~/WorkingData/BI_git/sandbox/kdelisle/SomaR_Releases/SomaR-1.8.0/revert.pkg.version.R')
revert.pkg.version('~/WorkingData/BI_git/sandbox/kdelisle/SomaR_Releases/SomaR-1.8.0/')
d = read.adat('~/WorkingData/Datasets/SomaLogic/Covance/CL-14-125.plasma.HybMedNormCalPassFail.adat')
d$SampleType
d = d[which(d$SampleType == 'Sample'), ]
d$AGE
d.log10 = log10(d)
d.log10 = log.soma.adat(d)
d.log10$CST3.2609.59.2
k = calc.lm(d.log10, ind.var = 'AGE')
k
candidates = head(rownames(k$stat.table))
candidates = head(rownames(k$stat.table), 100)
candidates
cf = 'R2'
cf = FSCostFxn_R2()
st = FSSearchMethod_ForwardParam()
mt = FSModelType_linreg(response='AGE')
fs.mcp = FSMCP(d.log10, candidates.markers = candidates, model.type = mt, search.type = st, cost.fxn = cf, runs=5, folds=5, random.seed=180228)
fs.mcp = FSMCP(d.log10, candidates.markers = candidates, model.type = mt, search.method  = st, cost.fxn = cf, runs=5, folds=5, random.seed=180228)
fs.mcp = FSMCP(d.log10, candidate.markers = candidates, model.type = mt, search.method  = st, cost.fxn = cf, runs=5, folds=5, random.seed=180228)
fs.mcp
fs.res = Search(fs.setup, num.cores=4)
fs.res = Search(fs.mcp, num.cores=4)
library(doMC)
fs.res = Search(fs.mcp, num.cores=4)
plot(fs.res)
fs.res
WorldPhones
source("~/WorkingData/BI_git/sandbox/kdelisle/Essentials/SpecialtyColors.R")
col.string = fg.col.string
plot(fs.res)
fs.res$candidate.markers
fs.res$cross.val$Run1
?round
installed.packages()
z = installed.packages()
class(z)
z=data.frame(z)
z$License
z$License_is_FOSS
z$License_restricts_use
unique(z$License)
sort(unique(z$License))
which(z$License == 'Artistic-2.0')
z[15,]
library(psych)
install.packages('psych')
library(psych)
?principal
principal
isCorrelation
isSymmetric()
isSymmetric
isSymmetric
?isSymmetric
a = matrix(c(.66,4.39,0.89,-1.18), nrow=4)
m1.m2 = matrix(c(-.07-.24, -0.08-.06, 1.37-2.59, .44-.43), nrow=4)
s=c(0.05,0.02,0.06,0,0.02,0.01,-.02,0,0.06,0.02,0.65,0.03, 0,0,0,0.03,0.03), nrow=4)
s=matrix(c(0.05,0.02,0.06,0,0.02,0.01,-.02,0,0.06,0.02,0.65,0.03, 0,0,0,0.03,0.03), nrow=4)
s=matrix(c(0.05,0.02,0.06,0,0.02,0.01,-.02,0,0.06,0.02,0.65,0.03, 0,0.03,0.03), nrow=4)
s=matrix(c(0.05,0.02,0.06,0,0.02,0.01,-.02,0,0.06,0.02,0.65,0.03, 0,0,.03,0.03), nrow=4)
s
m1pm2 = matrix(c(-.07+.24, -0.08+.06, 1.37+2.59, .44+.43), nrow=4)
t(m1.m2) %*% solve(s) %*% m1pm2
a
m1 = matrix(c(-.07, -.08, 1.37, .44), nrow=4)
m2 = matrix(c(.24, 0.06, 2.59, 0.43), nrow=4)
m1
m2
( t(a) %*% m1 + t(a) %*% m2)/2
0.84^2 + 0.38^2
a = installed.packages()
a
a$License
class(a)
a = data.frame(a)
a$License
unique(a$License)
sort(unique(a$License))
sort(unique(a$License))
ept = rnorm(1000, 0,1)
dat = matrix( rnorm(5000000, 0,1), nrow = 1000)
dim(dat)
?lm
res = lm(ept~col[,1])
res = lm(ept~dat[,1])
res
summary(res)
s = summary(res)
s$cov.unscaled
s$adj.r.squared
s$r.squared
s$fstatistic
s[1]
}
uni = apply(dat, 2, function(col) {
s = summary(lm(ept ~ col))
c('rsq' = s$r.squared,
'p.val' = pf(s$fstatistic[1], s$fstatistic[2], s$fstatistic[3], lower.tail = FALSE)
)
})
class(uni)
uni
uni = data.frame(apply(dat, 2, function(col) {
s = summary(lm(ept ~ col))
c('rsq' = s$r.squared,
'p.val' = pf(s$fstatistic[1], s$fstatistic[2], s$fstatistic[3], lower.tail = FALSE)
)
}))
uni
uni[1,]
uni[2,]
uni$X1
rownames(uni)
uni = t(data.frame(apply(dat, 2, function(col) {
s = summary(lm(ept ~ col))
c('rsq' = s$r.squared,
'p.val' = pf(s$fstatistic[1], s$fstatistic[2], s$fstatistic[3], lower.tail = FALSE)
)
})))
uni
colnames(uni)
uni$rsq
class(uni)
uni = data.frame(t(apply(dat, 2, function(col) {
s = summary(lm(ept ~ col))
c('rsq' = s$r.squared,
'p.val' = pf(s$fstatistic[1], s$fstatistic[2], s$fstatistic[3], lower.tail = FALSE)
)
})))
uni$rsq
max(uni$rsq)
min(uni$rsq)
histogram(uni$rsq, breaks=50)
hist(uni$rsq, breaks=50)
max(uni$p.val.value)
min(uni$p.val.value)
uni = uni[order(uni$p.val.value), ]
head(uni)
library(glmnet)
install.packages("glmnet")
library(glmnet)
grp = sample(c(1,2,3,4,5), size=1000, replace=TRUE)
grp
table(grp)
g=1
trn.x = dat[ -which(grp==g), ]
trn.y = ept[ -which(grp==g), ]
trn.y = ept[ -which(grp==g)]
tst.x = dat[ which(grp==g), ]
tst.y = ept[ which(grp==g)]
m = glmnet(trn.x, trn.y, family='gaussian')
m
summary(m)
m$beta
m$lambda
plot(m)
m$a0
?glmnet
l = cv.glmnet(trn.x, trn.y, family='gaussian')$lambda.1se
l
m = glmnet(trn.x, trn.y, family='gaussian', lambda=l)
m
m$beta
coeff(m)
coef(m0)
coef(m)
plot(coef(m))
l = cv.glmnet(trn.x, trn.y, family='gaussian')
l$lambda
l$lambda.min
l = cv.glmnet(trn.x, trn.y, family='gaussian')$lambda.min
m = glmnet(trn.x, trn.y, family='gaussian', lambda=l)
plot(coef(m))
predict(m, tst.x)
p = predict(m, tst.x)
plot(p, txt.y)
plot(p, tst.y)
uni
head(uni)
setwd("/storage/Temp/NNFS")
z=1:100
z
z[75:100]
z[75:150]
100/33
ceil(100/33)
ceiling(100/33)
?sample
sample(1:100)
length(unique(sample(1:100)))
